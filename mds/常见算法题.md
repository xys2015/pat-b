
# 01. 实现strcat函数

编写strcat函数. 已知strcat函数的原型是:  

    char *strcat(char *strDest, const char *strSrc);

其中, strDest是目的字符串, strSrc是源字符串.  
(1) 不能调用C++/C的字符串库函数, 请编写函数strcat  
(2) strcat能把strSrc的内容连接到strDest, 为什么还要char *类型的返回值?  

解析: 进行字符串连接时, 首先要定位目标串strDest的串结束标记'\0', 然后将源串  
strSrc的第一个字符覆盖目标串的串结束标记'\0', 这步是关键, 后续的操作就与字符  
串赋值操作类似

答案:  
(1) 程序如下:  

```c
#include <stdio.h>

char *strcat (char *strDest, const char *strSrc);

int main () {
    char str1[20] = "hello";
    const char *str2 = "-world0!";
    strcat(str1, str2);
    printf("%s\n", str1);
    return 0;
}

char *strcat (char *strDest, const char *strSrc) {
    char *p = strDest; // p初始指向strDest字符串第一个位置
    while (*p != '\0') {
        p++;
    } // 循环结束后 *p = '\0'

    // 不断赋值, 指针同时后移一位.
    // 当strSrc移到最后一位, 也就是发生了*p = '\0'时, 退出循环
    while (*p = *strSrc) {
        p++;
        strSrc++;
    }
    return strDest;
}

```

(2) 方便给其它变量赋值

# 02. 求字符串的长度-实现strlen

```c
#include <stdio.h>

int strlen(char *string);

int main () {
    char *name = "hello-world";
    printf("%d\n", strlen(name));
    return 0;
}

int strlen(char *str) {
    int length = 0;
    while (*str != '\0') {
        length += 1;
        str++; // 让str指向下个字符
    }
    return length;
}
```

# 03. 利用putchar打印字符串

```c
#include <stdio.h>

int strlen(char *string);

int main () {
    char *name = "hello-world";
    while (*name != '\0') {
        putchar(*name);
        name++;
    }
    return 0;
}

```

# 04. 翻转字符串

实现思路:  
采用镜像翻转的思路, 看起来就相当于把字符串对折. 首先2个指针left和right,  
使它们分别指向要翻转的字符串第1位和最后一位. 给出的字符串要么是奇数个要么  
是偶数个, 但不管怎样, 当left从左往右而right从右往左, 只要满足left < right  
就开始交换.  

完整代码:

```c
#include <stdio.h>

void reverse_string (char *string);

int main () {
    char str[20] = "hello-world";
    printf("%s\n", str);
    reverse_string(str);
    printf("%s\n", str);
    return 0;
}

void reverse_string (char *string) {
    char *left = string;
    char *right = string;
    char tmp; // 交换变量临时用

    while (*right != '\0') {
        right++;
    }
    right--; // 现在right指向字符串最后一位(不是'\0')

    while (left < right) {
        tmp = *left;
        *left = *right;
        *right = tmp;
        left++;
        right--;
    }
}


```

# 05. 实现字符串比较

```c
#include <stdio.h>

int strcmp (char *source, char *dest);

int main () {
    char str1[20] = "hello-";
    char str2[20] = "hello-";
    int flag;
    flag = strcmp(str1, str2);
    if (flag == 1) {
        printf("字符串相等\n");
    } else {
        printf("字符串不等\n");
    }

    return 0;
}

int strcmp (char *source, char *dest) {
    int isEqual = 1; // 默认相等
    while (*source != '\0' || *dest != '\0') {
        if (*source != *dest) {
            isEqual = -1;
            break; // 只要有一个字符不等, 循环提前结束
        }
        source++;
        dest++;
    }
    return isEqual;
}


```

# 06. 字符串去重

参考链接: http://www.hawstein.com/posts/1.3.html

输入: hello 输出: helo

第一种实现: 不新开数组, 也就是原地去重. 

```c
#include <stdio.h>
#include <string.h>

void removeDuplicate(char str[]);

int main (void) {
    char name[] = "hello";
    removeDuplicate(name);
    printf("%s\n", name);
    return 0;
}

void removeDuplicate(char str[]) {
    int len = strlen(str);
    int p = 0;
    int i;
    int j;
    for (i=0; i<len; i++) {
        if (str[i] != '\0') {
            str[p++] = str[i];
            for (j=i+1; j<len; j++) {
                if (str[i] == str[j]) {
                    str[j] = '\0';
                }
            }
        }
    }
    str[p] = '\0';
}
```

上面的代码一共出现了3次'\0', 前2次的'\0'没有什么特殊含义, 可以替换成任何在所给字符串中  
不会出现的字符. 最后一个'\0'则是C语言中特有的, 是字符串结束标志.  
就是把所有重复的元素标记成'\0', 那么剩下的元素则是不重复的元素, 通过变量p, 把这些元素重新  
添加到结果字符串中即可.  


第二种实现: 新开数组实现.

```c
#include <stdio.h>
#include <string.h>

void removeDuplicate(char str[], char res[]);

int main (void) {
    char name[20] = "sdfsssww";
    char res[20];
    removeDuplicate(name, res);
    printf("%s\n", res);
    return 0;
}

void removeDuplicate(char str[], char res[]) {
    int slen = strlen(str);
    int rlen = 0;
    int flag;        // 元素重复标志
    int i;
    int j;
    for (i=0; i<slen; i++) {
        flag = 0;
        for (j=0; j<rlen; j++) {
        // 每次都把结果数组遍历一遍, 与当前字符比较, 有重复
        // 就标记为 1
            if (res[j] == str[i]) flag = 1;
        }
        if (flag == 0) {
            res[rlen++] = str[i];
        }
    }
    res[rlen] = '\0';
}
```

第三种, 一层循环, 开个ASCII数组进行标记

```c
#include <stdio.h>
#include <string.h>

void removeDuplicate(char str[]);

int main (void) {
    char name[] = "wwwwsssspp";
    removeDuplicate(name);
    printf("%s\n", name);
    return 0;
}

void removeDuplicate(char str[]) {
    int len = strlen(str);
    int ascii[128] = {0};
    int p = 0;
    int i;

    for (i=0; i<len; i++) {
        if (ascii[str[i]] == 0) {
            ascii[str[i]] = 1;
            str[p++] = str[i];
        }
    }
    str[p] = '\0';
}
```

第四种, 也是新开ASCII数组进行标记, 实现去2重, 比如输入: sswqswww, 输出: sswqsw

```c
#include <stdio.h>
#include <string.h>

void removeDuplicate(char str[]);

int main (void) {
    char name[] = "sswqswww";
    removeDuplicate(name);
    printf("%s\n", name);
    return 0;
}

void removeDuplicate(char str[]) {
    int len = strlen(str);
    int ascii[128] = {0};
    int p = 0;
    int i;

    for (i=0; i<len; i++) {
        if (ascii[str[i]] != 2) {
            ascii[str[i]]++;
            str[p++] = str[i];
        }
    }
    str[p] = '\0';
}
```

第五种, 上面的代码简单改下, 既可以实现去n重

```c
#include <stdio.h>
#include <string.h>

void removeDuplicate(char str[], int n)

int main (void) {
    char name[] = "sswqswww";
    removeDuplicate(name, 2);
    printf("%s\n", name);
    return 0;
}

void removeDuplicate(char str[], int n) {
    int len = strlen(str);
    int ascii[128] = {0};
    int p = 0;
    int i;

    for (i=0; i<len; i++) {
        if (ascii[str[i]] != n) {
            ascii[str[i]]++;
            str[p++] = str[i];
        }
    }
    str[p] = '\0';
}
```

# 07. 最大公约数

英文: greatest common divisor

测试用例: (319, 377）= 29

解法1: 穷举

```c
#include <stdio.h>

int gcd (int m, int n);

int main(void) {
    printf("%d\n", gcd(6, 9));
    return 0;
}

// m != 0 && n != 0
int gcd (int m, int n) {
    int i;
    for (i=m; i>=1; i--) {
        if (m % i == 0 && n % i == 0) {
            return i;
        }
    }
}
```

解法2: 辗转相除法

```c
// m != 0 && n != 0
int gcd (int m, int n) {
    int mod = n; // 初始化成非0值
    while (mod != 0) {
        mod = m % n;
        m = n;
        n = mod;
    }
    return m;
}
```

# 08. 最小公倍数

英文: lowest common multiple

先求最大公约数, 再求最大公倍数.















